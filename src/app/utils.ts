import {Octokit} from '@octokit/core';
export const LOCAL_STORAGE_SETTINGS = 'semantic-token-settings';

export const rgbStringToHexString = (rgba) => {
    let sep = rgba.indexOf(',') > -1 ? ',' : ' ';
    rgba = rgba.substr(5).split(')')[0].split(sep);

    // Strip the slash if using space-separated syntax
    if (rgba.indexOf('/') > -1) rgba.splice(3, 1);

    for (let R in rgba) {
        let r = rgba[R];
        if (r.indexOf('%') > -1) {
            let p = r.substr(0, r.length - 1) / 100;

            if (R < 3) {
                rgba[R] = Math.round(p * 255);
            } else {
                rgba[R] = p;
            }
        }
    }
    let r = (+rgba[0]).toString(16),
        g = (+rgba[1]).toString(16),
        b = (+rgba[2]).toString(16),
        a = Math.round(+rgba[3] * 255).toString(16);

    if (r.length == 1) r = '0' + r;
    if (g.length == 1) g = '0' + g;
    if (b.length == 1) b = '0' + b;
    if (a.length == 1) a = '0' + a;

    return '#' + r + g + b + a;
};

export const rgbToHex = (rgb) => {
    // https://github.com/Ahmad-Amin/figmaPlugin/blob/f27c57245a51248857df4cf278c5599508c517f2/src/class_functions/classes/classes.js
    let r = rgb.r;
    let g = rgb.g;
    let b = rgb.b;

    //figma gives rgb values in [0,1] we convert it to [1,255]
    r = Math.round(rgb.r * 255);
    g = Math.round(rgb.g * 255);
    b = Math.round(rgb.b * 255);

    //rgb values to hexadecimal values
    r = r.toString(16);
    g = g.toString(16);
    b = b.toString(16);
    if (r.length == 1) r = '0' + r;
    if (g.length == 1) g = '0' + g;
    if (b.length == 1) b = '0' + b;
    return `#${r.toUpperCase() + g.toUpperCase() + b.toUpperCase()}`;
};

// accepts either a hex string or RGB for color parameter
export const createColorStyle = (name: string, color: RGB | string, description: string) => {
    // returns input value if already RGB; otherwise converts from hex to RGB
    const convertToRGB = (color: string | RGB) => {
        // can't use typeof here because RGB is an interface type
        if ((color as RGB).hasOwnProperty('r')) {
            return color as RGB;
        }
        const hex = (color as String).replace('#', '');
        const rgb: RGB = {
            r: parseInt(hex.substr(0, 2), 16) / 255,
            g: parseInt(hex.substr(2, 2), 16) / 255,
            b: parseInt(hex.substr(4, 2), 16) / 255,
        };
        return rgb;
    };
    // const style = figma.createPaintStyle();
    // style.name = name;
    const paint: SolidPaint = {
        type: 'SOLID',
        color: convertToRGB(color),
        opacity: 1,
        blendMode: 'NORMAL',
    };
    return {name: name, paints: [paint], description: description};
};

export const saveFile = (content) => {
    // https://stackoverflow.com/questions/34156282/how-do-i-save-json-to-local-text-file
    let date = new Date();
    let fileName = `tokens.${date[Symbol.toPrimitive]('number')}.json`;

    var a = document.createElement('a');
    var file = new Blob([content], {type: 'text/plain'});
    a.href = URL.createObjectURL(file);
    a.download = fileName;
    a.click();
};

export const copyToClipboard = (value) => {
    // https://stackoverflow.com/questions/71873824/copy-text-to-clipboard-cannot-read-properties-of-undefined-reading-writetext
    const textArea = document.createElement('textarea');
    textArea.value = value;
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
        document.execCommand('copy');
        alert('Copied!');
    } catch (err) {
        alert('Oh no! There was an issue.');
    }
    document.body.removeChild(textArea);
};

export const saveToLocalStorage = (value) => {
    parent.postMessage(
        {
            pluginMessage: {
                type: 'save-api-key',
                message: {localStoreId: LOCAL_STORAGE_SETTINGS, localStoreValue: value},
            },
        },
        '*'
    );
    alert('Saved!');
};

// Creates a Gist. Not used.
export const makeRequest = async (json, localStore) => {
    const octokit = new Octokit({auth: localStore.apiKey});
    let date = new Date();
    let fileName = `tokens.${date[Symbol.toPrimitive]('number')}.json`;
    let pushObject;
    pushObject.description = 'Example of a gist';
    pushObject.public = false;
    pushObject.files = {};
    pushObject.files[fileName] = {content: json};
    let res = await octokit.request('POST /gists', pushObject);
    console.log(res.data);
};

export const pushTokensToGh = async (json, localStore) => {
    const settingValues = Object.keys(localStore);
    if (!settingValues.some((i) => settingValues.includes(i))) {
        alert('Configure your settings');
        return false;
    }

    const octokit = new Octokit({auth: localStore.apiKey});
    const commitMessage = `Tokens regenerated by Alias Creator Figma Plugin`;
    const commitAuthor = {name: 'Alias Creator Figma Plugin', email: 'design@reifyhealth.com'};

    let hasFile = await octokit
        .request('GET /repos/{owner}/{repo}/contents/{path}', {
            owner: localStore.ghOrg,
            repo: localStore.ghRepo,
            path: localStore.ghPath,
        })
        .then((result) => {
            return result;
        })
        .catch((err) => {
            return err;
        });

    if (hasFile.status === 200) {
        await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
            owner: localStore.ghOrg,
            repo: localStore.ghRepo,
            path: localStore.ghPath,
            message: commitMessage,
            content: btoa(json),
            sha: hasFile.data.sha,
            committer: commitAuthor,
        });
    } else {
        await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
            owner: localStore.ghOrg,
            repo: localStore.ghRepo,
            path: localStore.ghPath,
            message: commitMessage,
            content: btoa(json),
            committer: commitAuthor,
        });
    }

    alert('Updated!');
};

// buildObjWithValue('Brand/Dawn/dawn', '#FF7575')
export const buildObjWithValue = (path, value = '') => {
    let paths = path.split('/');
    paths.shift();
    return paths.reduceRight(
        (acc, item, index) => ({
            [item]: index === paths.length - 1 ? {value: value} : acc,
        }),
        {}
    );
};
